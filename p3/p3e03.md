### Raise
Levanta una excepcion. Por defecto, raise crea una excepción de la clase RuntimeError. Para lanzar una excepción de una clase específica, se puede poner el nombre de la clase como argumento de raise de la forma:
```ruby
def foo
  raise SomeException, 'A message'
rescue
  # ...
end
```

### Begin
Adentro del begin pones el codigo que sabes puede llegar a generar una excepcion. Es opcional en el manejo de excepciones. Es para delimitar el codigo problematico.

### Rescue
Cuando pones un rescue luego de un begin o suelto dentro de un metodo estas declarando un manejador de excepciones.
Al escribir rescue sin parámetros, el parámetro StandardError se toma por defecto. En cada rescue se pueden poner varias excepciones a tratar. Ejemplo simple:
```ruby
begin
  #
rescue UnTipoDeExcepcion
  #
rescue OtroTipoDeExcepcion
  #
else
  # Otras excepciones
end
```

Para saber acerca del tipo de excepción, hay que mapear el objeto Exception a una variable usando rescue:
```ruby
begin
  raise 'Test de excepcion'
rescue Exception => e
  puts e.message            # Test de excepción
  puts e.backtrace.inspect   # ["nombre de fichero:linea de la excepción"]
end
```


### Else
Lo usas cuando queres que se ejecute algo si **NO** se rescata ninguna excepcion.Ruby compara la excepción que produce el error, con cada rescue hasta que sea del mismo tipo; o sea una superclase de la excepción. Si la excepción no concuerda con ningún rescue, es como que el else la rescata.

Ejemplo del *else*:
```ruby
begin
  raise 'Oops'

rescue RuntimeError
  puts $!.inspect
  puts 'todo mal...'
else
  puts $!.inspect
  puts 'todo bien'
end
```

### Ensure
Usas el ensure cuando queres que algo se ejecute si o si, se haya rescatado una excepcion o no. Ejemplo de utilidad de uso: If you want to ensure a file is closed or release a mutex.

Ejemplo del *ensure*:
```ruby
def hoge
  begin
    raise 'Se ha producido un error' # lanza una excepción con el mensaje entre ''
  rescue  
    raise # raise again
  ensure  
    puts 'ensure' # will be executed
  end  
  puts 'end of func' # never be executed (in case there is an exception)
end  
```

### Retry
Not all errors are fatal. Some just indicate that you need to try again. Retry is built in to Ruby's exception rescuing system. It's quite simple. If you use "retry" in your rescue block it causes the section of code that was rescued to be run again. Let's look at an example.
```ruby
begin
  retries ||= 0
  puts "try ##{ retries }"
  raise "the roof"
rescue
  retry if (retries += 1) < 3
end

# ... outputs the following:
# try #0
# try #1
# try #2

```
There are a few things to note here:

    * When retry is called, all of the code in between begin and rescue is run again. It most definitely does not "pick up where it left off" or anything like that.

    * If you don't provide some mechanism to limit retries, you will wind up with an infinite loop. (por eso tenes q usar guardas como en el ejemplo !!!)

    * Code in both the begin and rescue blocks are able to access the same retries variable in the parent scope.



**NOTA:** recordar el criterio de continuacion ante el manejo de excepciones en Ruby es de terminacion !!!
